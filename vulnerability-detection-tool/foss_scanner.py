#!/usr/bin/env python3

import os
import json
import subprocess
import shutil
import re
import ast
import argparse
from pathlib import Path
from typing import List, Dict, Any, Optional

import pandas as pd
from datetime import datetime
import logging

import torch
from transformers import AutoTokenizer, AutoModelForCausalLM
import psycopg2
from psycopg2.extras import RealDictCursor


# ----------------------------------------------------------------------
# Logging
# ----------------------------------------------------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


class FOSSCHERUBScanner:
    """
    Core scanner:
    - Runs Semgrep on a target path
    - Uses heuristics + Qwen to classify CWE
    - Uses PostgreSQL CVE DB to enrich findings
    - Uses AST-based filters to drop obvious false positives
    """

    def __init__(self, db_config: Dict[str, Any], model_path: str):
        self.db_config = db_config
        self.model_path = model_path

        logger.info("=" * 60)
        logger.info("FOSS-CHERUB Vulnerability Scanner (LLM + Semgrep + DB)")
        logger.info("=" * 60)

        if not os.path.isdir(self.model_path):
            raise RuntimeError(f"Model path does not exist: {self.model_path}")

        self._init_database_connection()
        self._init_ai_model()
        self._init_mappings()

    # ------------------------------------------------------------------
    # Init
    # ------------------------------------------------------------------

    def _init_database_connection(self):
        """Connect to PostgreSQL CVE/CWE database."""
        try:
            self.db_conn = psycopg2.connect(
                host=self.db_config["host"],
                port=self.db_config["port"],
                database=self.db_config["database"],
                user=self.db_config["user"],
                password=self.db_config["password"],
            )
            logger.info("Connected to PostgreSQL CVE/CWE database")
        except Exception as e:
            logger.warning(f"Database connection failed: {e}")
            logger.warning("Continuing WITHOUT CVE enrichment (CVE will be N/A)")
            self.db_conn = None

    def _init_ai_model(self):
        """Load Qwen model for CWE classification."""
        try:
            logger.info(f"Loading Qwen model from: {self.model_path}")
            self.qwen_tokenizer = AutoTokenizer.from_pretrained(
                self.model_path,
                trust_remote_code=True,
            )
            self.qwen_model = AutoModelForCausalLM.from_pretrained(
                self.model_path,
                torch_dtype=torch.float16,
                device_map="auto",
                trust_remote_code=True,
            )
            self.device = "cuda" if torch.cuda.is_available() else "cpu"
            logger.info(f"Qwen model loaded on {self.device}")
        except Exception as e:
            logger.error(f"Model initialization failed: {e}")
            raise

    def _init_mappings(self):
        """Initialize language extensions and CWE/severity mappings."""
        self.language_extensions = {
            "Java": [".java"],
            "Python": [".py"],
            "JavaScript": [".js", ".jsx", ".ts", ".tsx"],
            "C": [".c", ".h"],
            "C++": [".cpp", ".cc", ".cxx", ".hpp", ".hxx", ".h++"],
            "PHP": [".php"],
            "C#": [".cs"],
            "Go": [".go"],
            "Ruby": [".rb"],
            "Rust": [".rs"],
        }

        self.cwe_to_vulnerability_name = {
            "CWE-79": "Cross-Site Scripting (XSS)",
            "CWE-89": "SQL Injection",
            "CWE-78": "OS Command Injection",
            "CWE-77": "Command Injection",
            "CWE-22": "Path Traversal",
            "CWE-352": "Cross-Site Request Forgery (CSRF)",
            "CWE-798": "Hard-coded Credentials",
            "CWE-327": "Weak Cryptographic Algorithm",
            "CWE-328": "Weak Hash Function",
            "CWE-862": "Missing Authorization",
            "CWE-863": "Incorrect Authorization",
            "CWE-287": "Improper Authentication",
            "CWE-306": "Missing Authentication",
            "CWE-611": "XML External Entity (XXE)",
            "CWE-601": "Open Redirect",
            "CWE-502": "Insecure Deserialization",
            "CWE-269": "Improper Privilege Management",
            "CWE-732": "Incorrect Permission Assignment",
            "CWE-120": "Buffer Overflow",
            "CWE-119": "Buffer Overflow",
            "CWE-787": "Out-of-bounds Write",
            "CWE-190": "Integer Overflow",
            "CWE-200": "Information Disclosure",
            "CWE-209": "Information Exposure Through Error Message",
            "CWE-319": "Cleartext Transmission",
            "CWE-326": "Inadequate Encryption Strength",
            "CWE-338": "Weak PRNG",
            "CWE-400": "Uncontrolled Resource Consumption (DoS)",
            "CWE-434": "Unrestricted File Upload",
            "CWE-476": "NULL Pointer Dereference",
            "CWE-522": "Insufficiently Protected Credentials",
            "CWE-532": "Information Exposure Through Log Files",
            "CWE-614": "Sensitive Cookie Without Secure Flag",
            "CWE-676": "Use of Potentially Dangerous Function",
            "CWE-759": "Use of One-Way Hash Without Salt",
            "CWE-829": "Inclusion of Untrusted Code",
            "CWE-918": "Server-Side Request Forgery (SSRF)",
        }

        self.cwe_severity_map = {
            # Critical
            "CWE-89": "CRITICAL",
            "CWE-78": "CRITICAL",
            "CWE-77": "CRITICAL",
            "CWE-502": "CRITICAL",
            "CWE-798": "CRITICAL",
            "CWE-287": "CRITICAL",
            "CWE-306": "CRITICAL",
            "CWE-787": "CRITICAL",
            "CWE-434": "CRITICAL",
            # High
            "CWE-79": "HIGH",
            "CWE-22": "HIGH",
            "CWE-352": "HIGH",
            "CWE-611": "HIGH",
            "CWE-918": "HIGH",
            "CWE-862": "HIGH",
            "CWE-863": "HIGH",
            "CWE-120": "HIGH",
            "CWE-119": "HIGH",
            "CWE-327": "HIGH",
            "CWE-522": "HIGH",
            # Medium
            "CWE-200": "MEDIUM",
            "CWE-209": "MEDIUM",
            "CWE-319": "MEDIUM",
            "CWE-326": "MEDIUM",
            "CWE-338": "MEDIUM",
            "CWE-400": "MEDIUM",
            "CWE-476": "MEDIUM",
            "CWE-532": "MEDIUM",
            "CWE-601": "MEDIUM",
            # Low
            "CWE-614": "LOW",
            "CWE-676": "LOW",
            "CWE-759": "LOW",
        }

    # ------------------------------------------------------------------
    # Utility helpers
    # ------------------------------------------------------------------

    def clean_macos_artifacts(self, path: str) -> None:
        """Delete __MACOSX and .DS_Store files."""
        removed = 0
        for root, dirs, files in os.walk(path):
            if "__MACOSX" in dirs:
                p = os.path.join(root, "__MACOSX")
                shutil.rmtree(p, ignore_errors=True)
                removed += 1
            for f in files:
                if f == ".DS_Store":
                    p = os.path.join(root, f)
                    try:
                        os.remove(p)
                        removed += 1
                    except Exception:
                        pass
        if removed:
            logger.info(f"Cleaned {removed} macOS artifacts")

    def detect_language(self, file_path: str) -> str:
        ext = Path(file_path).suffix.lower()
        for lang, exts in self.language_extensions.items():
            if ext in exts:
                return lang
        return "Unknown"

    def extract_code_snippet(self, file_path: str, line_number: int, context: int = 2) -> str:
        """Extract a few lines around the finding."""
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                lines = f.readlines()
            if not lines:
                return ""
            idx = max(0, line_number - 1)
            start = max(0, idx - context)
            end = min(len(lines), idx + context + 1)
            out = []
            for i in range(start, end):
                mark = ">>> " if i == idx else "    "
                out.append(f"{mark}{lines[i].rstrip()}")
            return "\n".join(out)
        except Exception as e:
            return f"[Error reading file: {e}]"

    # ------------------------------------------------------------------
    # Semgrep
    # ------------------------------------------------------------------

    def run_semgrep_scan(self, target_path: str) -> List[Dict[str, Any]]:
        """Run Semgrep with security rules."""
        logger.info(f"Running Semgrep on: {target_path}")
        results: List[Dict[str, Any]] = []

        configs = ["p/owasp-top-ten", "p/cwe-top-25", "p/security-audit", "auto"]

        for cfg in configs:
            try:
                cmd = [
                    "semgrep",
                    "--config",
                    cfg,
                    "--json",
                    "--quiet",
                    "--severity=ERROR",
                    "--severity=WARNING",
                    target_path,
                ]
                proc = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=600,
                )
                if proc.returncode not in (0, 1):
                    continue
                data = json.loads(proc.stdout or "{}")
                results.extend(data.get("results", []))
            except subprocess.TimeoutExpired:
                logger.warning(f"Semgrep timeout for config: {cfg}")
            except Exception as e:
                logger.warning(f"Semgrep error for config {cfg}: {e}")

        # Deduplicate
        unique: List[Dict[str, Any]] = []
        seen = set()
        for r in results:
            key = (r.get("path"), r.get("start", {}).get("line"))
            if key not in seen:
                seen.add(key)
                unique.append(r)

        logger.info(f"Semgrep produced {len(unique)} unique findings")
        return unique

    # ------------------------------------------------------------------
    # AST / heuristics
    # ------------------------------------------------------------------

    def _contains_real_eval_call(self, snippet: str) -> bool:
        """AST-based check for real eval()/exec() calls."""
        try:
            tree = ast.parse(snippet)
        except SyntaxError:
            return "eval(" in snippet or "exec(" in snippet

        class Finder(ast.NodeVisitor):
            def __init__(self):
                self.found = False

            def visit_Call(self, node: ast.Call):
                name = getattr(node.func, "id", None)
                if name in ("eval", "exec"):
                    self.found = True
                self.generic_visit(node)

        f = Finder()
        f.visit(tree)
        return f.found

    def _heuristic_cwe_from_pattern(self, message: str, code_snippet: str) -> Optional[str]:
        """
        Obvious CWE deductions based on patterns:
        - eval/exec       -> CWE-95
        - os.system/shell -> CWE-78
        - SQL             -> CWE-89
        - XSS HTML        -> CWE-79
        - path traversal  -> CWE-22
        """
        text = (message or "") + "\n" + (code_snippet or "")
        tl = text.lower()
        cl = (code_snippet or "").lower()

        if "eval(" in cl or " exec(" in cl:
            return "CWE-95"

        if "os.system(" in cl or ("subprocess" in cl and "shell=True" in code_snippet):
            return "CWE-78"

        if "cursor.execute" in cl or "conn.execute" in cl:
            return "CWE-89"
        if "select " in tl and " from " in tl:
            return "CWE-89"

        if ("<html" in tl or "<div" in tl or "<script" in tl) and (
            "request.args" in code_snippet or "request.form" in code_snippet
        ):
            return "CWE-79"

        if "open(" in cl and ("../" in cl or "user_input" in cl):
            return "CWE-22"

        return None

    # ------------------------------------------------------------------
    # CWE / CVE enrichment
    # ------------------------------------------------------------------

    def extract_cwe_from_semgrep(self, finding: Dict[str, Any]) -> Optional[str]:
        """Try to get CWE directly from Semgrep metadata."""
        metadata = finding.get("extra", {}).get("metadata", {})
        cwes = metadata.get("cwe", [])
        if isinstance(cwes, list) and cwes:
            return cwes[0]
        if isinstance(cwes, str) and cwes:
            return cwes

        # fallback: search in message
        msg = finding.get("extra", {}).get("message", "") or ""
        m = re.search(r"CWE-\d+", msg, re.IGNORECASE)
        if m:
            return m.group(0).upper()
        return None

    def classify_cwe_with_qwen(self, message: str, code_snippet: str) -> str:
        """Combine heuristics + Qwen to classify CWE."""
        heuristic = self._heuristic_cwe_from_pattern(message, code_snippet)
        if heuristic:
            return heuristic

        try:
            prompt = f"""You are a security expert. Analyze this vulnerability and identify the CWE ID.

Security Finding: {message}
Code:
{code_snippet[:200]}

Provide ONLY the CWE ID (format: CWE-XXX). Examples: CWE-79, CWE-89, CWE-78

CWE ID:"""

            inputs = self.qwen_tokenizer(prompt, return_tensors="pt").to(self.device)
            with torch.no_grad():
                outputs = self.qwen_model.generate(
                    **inputs,
                    max_new_tokens=20,
                    temperature=0.3,
                    do_sample=True,
                    top_p=0.9,
                )

            response = self.qwen_tokenizer.decode(outputs[0], skip_special_tokens=True)
            m = re.search(r"CWE-\d+", response, re.IGNORECASE)
            if not m:
                return "CWE-20"

            model_cwe = m.group(0).upper()

            heuristic_after = self._heuristic_cwe_from_pattern(message, code_snippet)
            if heuristic_after and heuristic_after != model_cwe:
                logger.info(f"Overriding model CWE {model_cwe} with heuristic {heuristic_after}")
                return heuristic_after

            return model_cwe
        except Exception as e:
            logger.warning(f"CWE classification error: {e}")
            return "CWE-20"

    def generate_vulnerability_name(self, message: str, cwe_id: str) -> str:
        """Short human-readable vulnerability name using mappings + regex."""
        cwe_clean = cwe_id.split(":")[0].strip() if ":" in cwe_id else cwe_id
        if cwe_clean in self.cwe_to_vulnerability_name:
            return self.cwe_to_vulnerability_name[cwe_clean]

        patterns = [
            r"(SQL[- ]?Injection)",
            r"(XSS|Cross[- ]?Site[- ]?Scripting)",
            r"(Command[- ]?Injection)",
            r"(Path[- ]?Traversal)",
            r"(Buffer[- ]?Overflow)",
            r"(Hard[- ]?coded[- ]?Credentials?)",
            r"(Weak[- ]?Crypto|Weak[- ]?Cryptographic)",
            r"(XXE)",
            r"(CSRF)",
            r"(DoS|Denial[- ]?of[- ]?Service)",
            r"(SSRF)",
            r"(Deserialization)",
            r"(Information[- ]?Disclosure)",
        ]
        for p in patterns:
            m = re.search(p, message, re.IGNORECASE)
            if m:
                return m.group(1).strip()
        return f"Security Vulnerability ({cwe_clean})"

    def query_cve_database(self, cwe_id: str, language: str = None) -> List[Dict[str, Any]]:
        """Ask Postgres for CVEs linked to this CWE."""
        if not self.db_conn:
            return []

        cwe_clean = cwe_id.split(":")[0].strip() if ":" in cwe_id else cwe_id
        try:
            with self.db_conn.cursor(cursor_factory=RealDictCursor) as cur:
                query = """
                    SELECT 
                        cve_id,
                        description,
                        cvss_base_severity AS severity,
                        cvss_base_score AS cvss_score,
                        published_date
                    FROM cve
                    WHERE %s = ANY(cwe_ids)
                """
                params = [cwe_clean]
                if language and language.lower() != "unknown":
                    query += " AND description ILIKE %s"
                    params.append(f"%{language}%")
                query += " ORDER BY cvss_base_score DESC NULLS LAST, published_date DESC NULLS LAST LIMIT 5"
                cur.execute(query, params)
                rows = cur.fetchall()
                return [dict(r) for r in rows]
        except Exception as e:
            logger.warning(f"CVEs query failed for {cwe_clean}: {e}")
            return []

    def calculate_severity(self, cwe_id: str, cvss_score: Optional[float]) -> str:
        """Derive severity from CWE class and optional CVSS."""
        cwe_clean = cwe_id.split(":")[0].strip() if ":" in cwe_id else cwe_id
        if cwe_clean in self.cwe_severity_map:
            return self.cwe_severity_map[cwe_clean]

        if cvss_score is not None:
            try:
                s = float(cvss_score)
                if s >= 9.0:
                    return "CRITICAL"
                if s >= 7.0:
                    return "HIGH"
                if s >= 4.0:
                    return "MEDIUM"
                return "LOW"
            except Exception:
                pass
        return "MEDIUM"

    # ------------------------------------------------------------------
    # False-positive filter / refinement
    # ------------------------------------------------------------------

        def refine_vulnerability(self, v: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Kill obvious false positives and fix mislabels.

        - Hard-drop anything whose text says it's "not vulnerable"
        - Drop eval FPs like no_eval_safe
        - Drop parameterized SQL findings
        - Drop CREATE TABLE noise
        - Drop escaped XSS
        - Normalize CWE for os.system / eval / SQL
        """

        # -----------------------------
        # 0) Collect all text we have
        # -----------------------------
        text_fields = []

        for key in ("vulnerability", "ai_explanation", "details", "message", "raw_message"):
            val = v.get(key)
            if isinstance(val, str):
                text_fields.append(val)

        code = v.get("code_snippet") or ""
        text_fields.append(code)

        text_blob = " ".join(text_fields).lower()
        cwe = (v.get("cwe_id") or "").upper()

        # -----------------------------
        # 1) Hard filter: "Not Vulnerable"
        # -----------------------------
        NEG_PATTERNS = [
            "not vulnerable",
            "no vulnerable code",
            "the provided code snippet is not vulnerable",
            "this code is safe",
            "this snippet is safe",
            "code is already correct and not vulnerable",
        ]

        if any(pat in text_blob for pat in NEG_PATTERNS):
            logger.info(
                f"Dropping finding as 'not vulnerable': "
                f"file={v.get('file_path')} line={v.get('line_number')} cwe={cwe}"
            )
            return None

        # ALSO: if the short name itself is literally "Not Vulnerable", kill it
        vuln_name = (v.get("vulnerability") or "").strip().lower()
        if vuln_name.startswith("not vulnerable") or vuln_name == "no vulnerability":
            logger.info(
                f"Dropping finding with 'Not Vulnerable' name: "
                f"file={v.get('file_path')} line={v.get('line_number')} cwe={cwe}"
            )
            return None

        # -----------------------------
        # 2) Eval / exec: keep only real calls
        # -----------------------------
        if "eval" in text_blob or "exec" in text_blob:
            if not self._contains_real_eval_call(code):
                logger.info(
                    f"Dropping eval FP (no real eval/exec call): "
                    f"file={v.get('file_path')} line={v.get('line_number')}"
                )
                return None
            v["cwe_id"] = "CWE-95"

        # -----------------------------
        # 3) SQL: drop safe, normalize dangerous
        # -----------------------------
        if "cursor.execute" in code or "conn.execute" in code:
            up = code.upper()
            # Parameterized SELECT -> safe
            if ("?" in code or "%s" in code) and "SELECT" in up:
                logger.info(
                    f"Dropping parameterized SQL (safe): "
                    f"file={v.get('file_path')} line={v.get('line_number')}"
                )
                return None
            # Constant DDL -> safe
            if "CREATE TABLE" in up and "user_input" not in code.lower():
                logger.info(
                    f"Dropping constant DDL SQL (safe): "
                    f"file={v.get('file_path')} line={v.get('line_number')}"
                )
                return None
            # Remaining SELECT -> treat as SQL injection-ish
            if "SELECT" in up:
                v["cwe_id"] = "CWE-89"

        # -----------------------------
        # 4) XSS: escaped input should be safe
        # -----------------------------
        if "CWE-79" in cwe or "xss" in text_blob:
            if "escape(" in code and "request.args" in code:
                logger.info(
                    f"Dropping escaped XSS (safe): "
                    f"file={v.get('file_path')} line={v.get('line_number')}"
                )
                return None

        # -----------------------------
        # 5) Command injection - normalize CWE
        # -----------------------------
        if "os.system(" in code:
            v["cwe_id"] = "CWE-78"

        return v


    # ------------------------------------------------------------------
    # Top-level scan
    # ------------------------------------------------------------------

    def scan_path(self, target_path: str) -> pd.DataFrame:
        """Scan a target directory and return DataFrame of findings."""
        target_path = os.path.abspath(target_path)
        logger.info("\n" + "=" * 60)
        logger.info(f"Scanning target: {target_path}")
        logger.info("=" * 60)

        self.clean_macos_artifacts(target_path)

        semgrep_findings = self.run_semgrep_scan(target_path)
        records: List[Dict[str, Any]] = []

        for f in semgrep_findings:
            try:
                file_path = f.get("path", "")
                line = f.get("start", {}).get("line", 0)
                message = f.get("extra", {}).get("message", "")

                abs_file = (
                    file_path if os.path.isabs(file_path) else os.path.join(target_path, file_path)
                )
                code_snippet = self.extract_code_snippet(abs_file, line)
                language = self.detect_language(file_path)

                cwe_id = self.extract_cwe_from_semgrep(f)
                if not cwe_id:
                    cwe_id = self.classify_cwe_with_qwen(message, code_snippet)

                vuln_name = self.generate_vulnerability_name(message, cwe_id)
                cwe_clean = cwe_id.split(":")[0].strip() if ":" in cwe_id else cwe_id

                cve_entries = self.query_cve_database(cwe_clean, language)
                if cve_entries:
                    cve_id = cve_entries[0].get("cve_id", "N/A")
                    cvss_score = cve_entries[0].get("cvss_score", None)
                else:
                    cve_id = "N/A"
                    cvss_score = None

                severity = self.calculate_severity(cwe_clean, cvss_score)

                record = {
                    "sno": len(records) + 1,
                    "primary_language": language,
                    "vulnerability": vuln_name,
                    # if your AI explanation is stored elsewhere, wire it here:
                    # "ai_explanation": full_ai_explanation_text,
                    "cve_id": cve_id,
                    "severity": severity,
                    "cwe_id": cwe_clean,
                    "file_path": file_path,
                    "line_number": str(line),
                    "code_snippet": code_snippet[:500],
                }

                record = self.refine_vulnerability(record)
                if record:
                    records.append(record)

            except Exception as e:
                logger.warning(f"Error processing finding: {e}")
                continue

        df = pd.DataFrame(records)
        if not df.empty:
            severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3}
            df["severity_rank"] = df["severity"].map(severity_order).fillna(4)
            df = df.sort_values("severity_rank").drop(columns=["severity_rank"])
            df["sno"] = range(1, len(df) + 1)

        logger.info(f"\nFinal findings after refinement: {len(df)}")
        if not df.empty:
            for sev, count in df["severity"].value_counts().items():
                logger.info(f"  {sev}: {count}")

        return df

    def __del__(self):
        try:
            if hasattr(self, "db_conn") and self.db_conn:
                self.db_conn.close()
        except Exception:
            pass


# ----------------------------------------------------------------------
# CLI
# ----------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description="FOSS-CHERUB LLM+Semgrep Scanner")
    parser.add_argument(
        "--target",
        required=True,
        help="Path to project root to scan.",
    )
    parser.add_argument("--db-host", default="foss-cherub-db")
    parser.add_argument("--db-port", type=int, default=5432)
    parser.add_argument("--db-name", default="foss_cherub")
    parser.add_argument("--db-user", default="postgres")
    parser.add_argument("--db-pass", default="foss_cherub_2024")
    parser.add_argument(
        "--model-path",
        required=True,
        help="Path to fine-tuned Qwen model (e.g. data_processing/merged_model)",
    )
    parser.add_argument(
        "--out",
        default=None,
        help="Output CSV file (default: foss_cherub_results_<timestamp>.csv)",
    )

    args = parser.parse_args()

    if not os.path.exists(args.target):
        raise SystemExit(f"Target path does not exist: {args.target}")

    db_config = {
        "host": args.db_host,
        "port": args.db_port,
        "database": args.db_name,
        "user": args.db_user,
        "password": args.db_pass,
    }

    scanner = FOSSCHERUBScanner(db_config, args.model_path)
    df = scanner.scan_path(args.target)

    if df.empty:
        print("No findings after refinement (or everything was noise).")
        return

    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    out_file = args.out or f"foss_cherub_results_{ts}.csv"
    df.to_csv(out_file, index=False)
    print(f"\nScan complete. Results written to: {out_file}\n")


if __name__ == "__main__":
    main()
